$date
	Sat Jul 31 15:58:40 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module four_adder_tb $end
$var wire 4 ! s [3:0] $end
$var wire 1 " cout $end
$var reg 4 # a [3:0] $end
$var reg 4 $ b [3:0] $end
$var reg 1 % cin $end
$scope module DUT $end
$var wire 4 & a [3:0] $end
$var wire 4 ' b [3:0] $end
$var wire 1 % cin $end
$var wire 4 ( s [3:0] $end
$var wire 1 " cout $end
$var wire 3 ) W [2:0] $end
$scope module f0 $end
$var wire 1 * A $end
$var wire 1 + B $end
$var wire 1 % Cin $end
$var wire 1 , Cout $end
$var wire 1 - S $end
$var wire 1 . w1 $end
$var wire 1 / w2 $end
$var wire 1 0 w3 $end
$upscope $end
$scope module f1 $end
$var wire 1 1 A $end
$var wire 1 2 B $end
$var wire 1 3 Cin $end
$var wire 1 4 Cout $end
$var wire 1 5 S $end
$var wire 1 6 w1 $end
$var wire 1 7 w2 $end
$var wire 1 8 w3 $end
$upscope $end
$scope module f2 $end
$var wire 1 9 A $end
$var wire 1 : B $end
$var wire 1 ; Cin $end
$var wire 1 < Cout $end
$var wire 1 = S $end
$var wire 1 > w1 $end
$var wire 1 ? w2 $end
$var wire 1 @ w3 $end
$upscope $end
$scope module f3 $end
$var wire 1 A A $end
$var wire 1 B B $end
$var wire 1 C Cin $end
$var wire 1 " Cout $end
$var wire 1 D S $end
$var wire 1 E w1 $end
$var wire 1 F w2 $end
$var wire 1 G w3 $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
x2
x1
x0
x/
x.
x-
x,
x+
x*
bx )
bx (
bx '
bx &
x%
bx $
bx #
x"
bx !
$end
#5
0=
0D
0;
0C
05
04
0<
0"
03
b0 !
b0 (
0-
07
0?
0F
b0 )
0,
0.
00
06
08
0>
0@
0E
0G
0/
0+
02
0:
0B
0*
01
09
0A
0%
b0 $
b0 '
b0 #
b0 &
#10
15
1-
1=
b1111 !
b1111 (
1D
16
1.
1>
1E
12
1*
19
1A
b10 $
b10 '
b1101 #
b1101 &
#15
1"
0D
1F
1C
1<
0=
1?
1;
14
05
17
13
b111 )
1,
b0 !
b0 (
0-
1/
1%
#20
0"
1D
0F
0C
b11 )
0<
15
07
b1110 !
b1110 (
1=
0?
06
18
0>
1+
0*
11
09
b11 $
b11 '
b1010 #
b1010 &
#25
05
03
0=
0,
0;
1-
0/
b1 !
b1 (
0D
1"
b0 )
04
0.
0E
1G
08
0+
02
1B
01
b1000 $
b1000 '
b1000 #
b1000 &
#30
